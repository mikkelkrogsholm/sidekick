<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/svg+xml" href="/logo.svg">
    <link rel="stylesheet" href="/styles/base.css" />
    <link rel="stylesheet" href="/styles/app.css" />
    <title>Embedded Chunks Viewer</title>
</head>
<body>
    <div class="app">
        <header class="topbar">
            <div class="container topbar__inner">
                <div class="brand">
                    <img src="/logo.svg" alt="Voice Transcription Logo" style="height: 32px; width: auto;">
                    <h1 class="brand__title">Embeddings</h1>
                    <span class="brand__meta" id="navSession">All sessions</span>
                </div>
                
                <div class="nav-links">
                    <a href="/dashboard.html" class="nav-link">Dashboard</a>
                    <a href="/" class="nav-link">Transcribe</a>
                    <a href="/viewer.html" class="nav-link active">Viewer</a>
                </div>
                
                <div class="badge">Chunks: <span id="totalChunks">0</span></div>
            </div>
        </header>

        <main class="viewer">
            <div class="container stack">
                <section class="card" style="padding: 16px;">
                    <div class="toolbar" style="display: grid; grid-template-columns: 1fr auto auto auto; gap: 12px; align-items: center;">
                        <input id="searchQuery" class="input" placeholder="Search…" />
                        <input id="searchLimit" class="input" type="number" min="1" value="5" style="width: 80px;" />
                        <button id="searchBtn" class="button button--primary">Search</button>
                        <button id="refreshBtn" class="button">Refresh</button>
                    </div>
                </section>

                <section class="card" style="padding: 8px 0; display: none;" id="searchResultsSection">
                    <div id="searchResults"></div>
                </section>

                <section class="card" style="padding: 16px;">
                    <h3>Filters</h3>
                    <div class="row" style="gap: 16px;">
                        <select id="sessionFilter" class="input" style="flex: 1;">
                            <option value="">All Sessions</option>
                        </select>
                        <input id="limitInput" class="input" type="number" value="50" min="1" max="1000" style="width: 100px;" />
                    </div>
                </section>

                <!-- Knowledge Sources Section -->
                <section class="card" style="padding: 16px; display: none;" id="knowledgeSection">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                        <h3 style="margin: 0;">Knowledge Sources</h3>
                        <div id="batchActions" style="display: none; gap: 8px;">
                            <button id="selectAllBtn" class="button button--secondary" style="padding: 6px 12px; font-size: 0.9rem;">Select All</button>
                            <button id="batchDeleteBtn" class="button button--danger" style="padding: 6px 12px; font-size: 0.9rem;">Delete Selected (<span id="selectedCount">0</span>)</button>
                        </div>
                    </div>
                    
                    <!-- Upload Area -->
                    <div id="uploadArea" class="upload-area" style="border: 2px dashed var(--color-border); border-radius: 8px; padding: 20px; text-align: center; margin: 16px 0; background: var(--color-bg-secondary);">
                        <p style="margin: 0 0 12px 0; color: var(--color-text-muted);">Drag & drop files here, or click to select</p>
                        <input type="file" id="fileInput" accept=".txt,.md,.pdf" multiple style="display: none;" />
                        <button id="selectFileBtn" class="button button--primary">Choose Files</button>
                        <p style="margin: 12px 0 0 0; font-size: 0.85rem; color: var(--color-text-muted);">Supported: TXT, MD, PDF (max 10MB)</p>
                    </div>
                    
                    <!-- Knowledge List -->
                    <!-- Upload Progress -->
                    <div id="uploadProgress" style="display: none; margin: 16px 0; padding: 12px; background: var(--color-bg); border-radius: 8px; border: 1px solid var(--color-border);">
                        <h4 style="margin: 0 0 12px 0;">Upload Progress</h4>
                        <div id="uploadProgressList"></div>
                    </div>
                    
                    <div id="knowledgeList" style="margin-top: 20px;">
                        <div style="padding: 10px; text-align: center; color: var(--color-text-muted);">
                            No knowledge sources uploaded
                        </div>
                    </div>
                </section>

                <section class="card" style="padding: 16px;">
                    <h3>Stats</h3>
                    <div id="stats" class="row" style="flex-wrap: wrap; gap: 16px;">
                        <div class="badge">Sessions: <span id="totalSessions">0</span></div>
                        <div class="badge">Avg length: <span id="avgLength">–</span></div>
                    </div>
                </section>

                <section class="card" style="padding: 8px 0;">
                    <div id="embeddingsList">
                        <div style="padding: 20px; text-align: center; color: var(--color-text-muted);">
                            Loading embeddings...
                        </div>
                    </div>
                </section>
            </div>
        </main>
    </div>

    <script>
        const sessionFilter = document.getElementById('sessionFilter');
        const limitInput = document.getElementById('limitInput');
        const refreshBtn = document.getElementById('refreshBtn');
        const embeddingsList = document.getElementById('embeddingsList');
        const searchQuery = document.getElementById('searchQuery');
        const searchLimit = document.getElementById('searchLimit');
        const searchBtn = document.getElementById('searchBtn');
        const searchResults = document.getElementById('searchResults');
        const searchResultsSection = document.getElementById('searchResultsSection');
        
        // Stats elements
        const totalChunks = document.getElementById('totalChunks');
        const totalSessions = document.getElementById('totalSessions');
        const avgLength = document.getElementById('avgLength');
        
        // Utility function to escape HTML to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        async function loadSessions() {
            try {
                const response = await fetch('/api/sessions');
                const sessions = await response.json();
                
                sessionFilter.innerHTML = '<option value="">All Sessions</option>';
                sessions.forEach(session => {
                    const option = document.createElement('option');
                    option.value = session.id;
                    option.textContent = `${session.name} (${session.total_transcripts} chunks)`;
                    sessionFilter.appendChild(option);
                });
                
                totalSessions.textContent = sessions.length;
            } catch (error) {
                console.error('Error loading sessions:', error);
            }
        }
        
        async function loadEmbeddings() {
            embeddingsList.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--color-text-muted);">Loading embeddings...</div>';
            
            try {
                const params = new URLSearchParams();
                if (sessionFilter.value) {
                    params.append('sessionId', sessionFilter.value);
                }
                params.append('limit', limitInput.value);
                
                const response = await fetch(`/api/embeddings?${params}`);
                if (!response.ok) throw new Error('Failed to load embeddings');
                
                const embeddings = await response.json();
                displayEmbeddings(embeddings);
                updateStats(embeddings);
            } catch (error) {
                console.error('Error loading embeddings:', error);
                embeddingsList.innerHTML = '<div style="padding: 20px; color: var(--color-danger);">Failed to load embeddings</div>';
            }
        }
        
        function displayEmbeddings(embeddings, isSearch = false) {
            const container = isSearch ? searchResults : embeddingsList;
            
            if (embeddings.length === 0) {
                container.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--color-text-muted);">No embeddings found</div>';
                return;
            }
            
            container.innerHTML = '';
            
            embeddings.forEach(embedding => {
                const row = document.createElement('div');
                row.className = 'row';
                row.style.padding = '12px 16px';
                row.style.borderBottom = '1px solid var(--color-border)';
                row.style.flexDirection = 'column';
                row.style.gap = '8px';
                row.dataset.rowid = embedding.rowid;
                row.dataset.sessionId = embedding.session_id;
                
                const startDate = new Date(embedding.started_at);
                const endDate = new Date(embedding.ended_at);
                const duration = Math.round((endDate - startDate) / 1000);
                
                // Create header with meta info
                const headerDiv = document.createElement('div');
                headerDiv.className = 'row';
                headerDiv.style.justifyContent = 'space-between';
                headerDiv.style.alignItems = 'flex-start';
                
                const metaDiv = document.createElement('div');
                metaDiv.style.display = 'flex';
                metaDiv.style.flexWrap = 'wrap';
                metaDiv.style.gap = '12px';
                metaDiv.style.fontSize = '0.85rem';
                metaDiv.style.color = 'var(--color-text-muted)';
                metaDiv.innerHTML = `
                    <span>${escapeHtml(startDate.toLocaleString())}</span>
                    <span>${duration}s</span>
                    <span>${escapeHtml(embedding.language)}</span>
                    <span>${embedding.content_length} chars</span>
                    ${embedding.distance !== undefined ? `<span style="background: var(--color-success); color: white; padding: 2px 6px; border-radius: 4px;">Score: ${(1 - embedding.distance).toFixed(3)}</span>` : ''}
                `;
                
                headerDiv.appendChild(metaDiv);
                
                // Add delete button (not for search results)
                if (!isSearch && embedding.rowid) {
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'button button--danger';
                    deleteBtn.style.padding = '4px 8px';
                    deleteBtn.style.fontSize = '0.85rem';
                    deleteBtn.textContent = 'Delete';
                    deleteBtn.onclick = () => deleteEmbedding(embedding.rowid, embedding.session_id);
                    headerDiv.appendChild(deleteBtn);
                }
                
                row.appendChild(headerDiv);
                
                // Add content
                const contentDiv = document.createElement('div');
                contentDiv.style.background = 'var(--color-bg)';
                contentDiv.style.padding = '12px';
                contentDiv.style.borderRadius = 'var(--radius-s)';
                contentDiv.style.fontFamily = 'monospace';
                contentDiv.style.fontSize = '0.9rem';
                contentDiv.style.lineHeight = '1.5';
                contentDiv.style.maxHeight = '200px';
                contentDiv.style.overflow = 'auto';
                contentDiv.textContent = embedding.content;
                row.appendChild(contentDiv);
                
                container.appendChild(row);
            });
        }
        
        // Delete an individual embedding
        async function deleteEmbedding(rowid, sessionId) {
            if (!confirm('Are you sure you want to delete this transcript chunk?')) {
                return;
            }
            
            try {
                const response = await fetch(`/api/embeddings/${rowid}`, {
                    method: 'DELETE',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ sessionId })
                });
                
                if (!response.ok) {
                    throw new Error('Failed to delete embedding');
                }
                
                const result = await response.json();
                console.log('Deleted embedding:', result);
                
                // Remove the row from UI
                const row = document.querySelector(`[data-rowid="${rowid}"]`);
                if (row) {
                    row.style.opacity = '0';
                    row.style.transform = 'translateX(-20px)';
                    row.style.transition = 'all 0.3s ease';
                    setTimeout(() => row.remove(), 300);
                }
                
                // Update stats
                loadEmbeddings();
            } catch (error) {
                console.error('Error deleting embedding:', error);
                alert('Failed to delete embedding');
            }
        }
        
        function updateStats(embeddings) {
            totalChunks.textContent = embeddings.length;
            
            if (embeddings.length > 0) {
                const totalLength = embeddings.reduce((sum, e) => sum + e.content_length, 0);
                avgLength.textContent = Math.round(totalLength / embeddings.length);
            } else {
                avgLength.textContent = '0';
            }
        }
        
        // Knowledge Management
        const knowledgeSection = document.getElementById('knowledgeSection');
        const knowledgeList = document.getElementById('knowledgeList');
        const fileInput = document.getElementById('fileInput');
        const selectFileBtn = document.getElementById('selectFileBtn');
        const uploadArea = document.getElementById('uploadArea');
        
        // Show/hide knowledge section based on session selection
        function updateKnowledgeSection() {
            const selectedSession = sessionFilter.value;
            if (selectedSession) {
                knowledgeSection.style.display = 'block';
                loadKnowledgeSources(selectedSession);
            } else {
                knowledgeSection.style.display = 'none';
            }
        }
        
        // Load knowledge sources for a session with retry logic
        async function loadKnowledgeSources(sessionId, retryCount = 0) {
            if (!sessionId) return;
            
            try {
                const response = await fetch(`/api/sessions/${sessionId}/knowledge`);
                
                // Handle rate limiting with exponential backoff
                if (response.status === 429) {
                    if (retryCount < 3) {
                        const delay = Math.pow(2, retryCount) * 1000; // 1s, 2s, 4s
                        console.log(`Rate limited, retrying in ${delay}ms...`);
                        await new Promise(resolve => setTimeout(resolve, delay));
                        return loadKnowledgeSources(sessionId, retryCount + 1);
                    }
                    throw new Error('Too many requests - please wait a moment');
                }
                
                if (!response.ok) throw new Error('Failed to load knowledge sources');
                
                const sources = await response.json();
                displayKnowledgeSources(sources);
            } catch (error) {
                console.error('Error loading knowledge sources:', error);
                const message = error.message.includes('Too many requests') 
                    ? 'Rate limited - please wait a moment'
                    : 'Failed to load knowledge sources';
                knowledgeList.innerHTML = `<div style="padding: 10px; color: var(--color-danger);">${message}</div>`;
            }
        }
        
        // Track selected items
        let selectedKnowledge = new Set();
        
        // Display knowledge sources
        function displayKnowledgeSources(sources) {
            const batchActions = document.getElementById('batchActions');
            
            if (sources.length === 0) {
                knowledgeList.innerHTML = '<div style="padding: 10px; text-align: center; color: var(--color-text-muted);">No knowledge sources uploaded</div>';
                batchActions.style.display = 'none';
                return;
            }
            
            // Show batch actions
            batchActions.style.display = 'flex';
            
            knowledgeList.innerHTML = '';
            sources.forEach(source => {
                const item = document.createElement('div');
                item.className = 'row';
                item.style.padding = '12px';
                item.style.borderBottom = '1px solid var(--color-border)';
                item.style.alignItems = 'center';
                item.style.gap = '12px';
                item.dataset.sourceId = source.id;
                
                // Checkbox
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'knowledge-checkbox';
                checkbox.checked = selectedKnowledge.has(source.id);
                checkbox.onchange = () => {
                    if (checkbox.checked) {
                        selectedKnowledge.add(source.id);
                    } else {
                        selectedKnowledge.delete(source.id);
                    }
                    updateSelectedCount();
                };
                
                const infoDiv = document.createElement('div');
                infoDiv.style.flex = '1';
                infoDiv.style.cursor = source.status === 'ready' ? 'pointer' : 'default';
                
                const statusBadge = source.status === 'ready' 
                    ? '<span style="background: var(--color-success); color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.85rem;">Ready</span>'
                    : source.status === 'processing' 
                    ? '<span style="background: var(--color-warning); color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.85rem;">Processing</span>'
                    : source.status === 'error'
                    ? '<span style="background: var(--color-danger); color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.85rem;">Error</span>'
                    : '<span style="background: var(--color-border); color: var(--color-text); padding: 2px 6px; border-radius: 4px; font-size: 0.85rem;">Queued</span>';
                
                infoDiv.innerHTML = `
                    <div style="font-weight: 600; margin-bottom: 4px;">${escapeHtml(source.name)}</div>
                    <div style="font-size: 0.85rem; color: var(--color-text-muted);">
                        ${statusBadge}
                        <span style="margin-left: 8px;">Type: ${escapeHtml(source.type.toUpperCase())}</span>
                        ${source.chunkCount ? `<span style="margin-left: 8px;">Chunks: ${source.chunkCount}</span>` : ''}
                        ${source.error ? `<span style="margin-left: 8px; color: var(--color-danger);">Error: ${escapeHtml(source.error)}</span>` : ''}
                    </div>
                `;
                
                // Add click handler to view content
                if (source.status === 'ready') {
                    infoDiv.onclick = () => viewKnowledgeSource(sessionFilter.value, source.id, source.name);
                    infoDiv.title = 'Click to view content';
                }
                
                const actionsDiv = document.createElement('div');
                actionsDiv.style.display = 'flex';
                actionsDiv.style.gap = '8px';
                
                if (source.status === 'ready') {
                    const viewBtn = document.createElement('button');
                    viewBtn.className = 'button button--primary';
                    viewBtn.style.padding = '4px 8px';
                    viewBtn.style.fontSize = '0.85rem';
                    viewBtn.textContent = 'View';
                    viewBtn.onclick = () => viewKnowledgeSource(sessionFilter.value, source.id, source.name);
                    actionsDiv.appendChild(viewBtn);
                }
                
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'button button--danger';
                deleteBtn.style.padding = '4px 8px';
                deleteBtn.style.fontSize = '0.85rem';
                deleteBtn.textContent = 'Delete';
                deleteBtn.onclick = () => deleteKnowledgeSource(sessionFilter.value, source.id);
                actionsDiv.appendChild(deleteBtn);
                
                item.appendChild(checkbox);
                item.appendChild(infoDiv);
                item.appendChild(actionsDiv);
                knowledgeList.appendChild(item);
            });
            
            updateSelectedCount();
        }
        
        // Update selected count display
        function updateSelectedCount() {
            const countSpan = document.getElementById('selectedCount');
            countSpan.textContent = selectedKnowledge.size;
            
            const batchDeleteBtn = document.getElementById('batchDeleteBtn');
            batchDeleteBtn.disabled = selectedKnowledge.size === 0;
        }
        
        // View knowledge source content
        async function viewKnowledgeSource(sessionId, sourceId, sourceName) {
            try {
                // Fetch chunks directly from the chunks endpoint
                const response = await fetch(`/api/sessions/${sessionId}/knowledge/${sourceId}/chunks`);
                if (!response.ok) throw new Error('Failed to load knowledge chunks');
                
                const data = await response.json();
                
                // Create modal to display content
                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: rgba(0, 0, 0, 0.5);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 1000;
                `;
                
                const modalContent = document.createElement('div');
                modalContent.style.cssText = `
                    background: var(--color-bg);
                    border-radius: var(--radius-l);
                    padding: 24px;
                    max-width: 80%;
                    max-height: 80%;
                    overflow: auto;
                    box-shadow: var(--shadow-xl);
                `;
                
                const header = document.createElement('div');
                header.style.cssText = `
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    margin-bottom: 16px;
                    padding-bottom: 16px;
                    border-bottom: 1px solid var(--color-border);
                `;
                
                header.innerHTML = `
                    <h3 style="margin: 0;">${escapeHtml(sourceName)}</h3>
                    <button class="button button--secondary" style="padding: 4px 8px;">Close</button>
                `;
                
                const closeBtn = header.querySelector('button');
                closeBtn.onclick = () => document.body.removeChild(modal);
                
                const content = document.createElement('div');
                content.style.cssText = `
                    background: var(--color-bg-secondary);
                    padding: 16px;
                    border-radius: var(--radius-m);
                    max-height: 60vh;
                    overflow: auto;
                `;
                
                // Get chunks from the response
                const chunks = data.chunks || [];
                
                if (chunks.length > 0) {
                    content.innerHTML = `
                        <div style="margin-bottom: 12px; color: var(--color-text-muted); font-size: 0.9rem;">
                            Total chunks: ${chunks.length}
                        </div>
                        ${chunks.map((chunk, index) => `
                            <div style="margin-bottom: 16px; padding: 12px; background: var(--color-bg); border-radius: var(--radius-s);">
                                <div style="font-weight: 600; margin-bottom: 8px; color: var(--color-primary);">Chunk ${index + 1}</div>
                                <div style="white-space: pre-wrap; font-family: monospace; font-size: 0.9rem; line-height: 1.5;">${escapeHtml(chunk.content || chunk.text || chunk)}</div>
                            </div>
                        `).join('')}
                    `;
                } else if (data.status === 'processing' || data.status === 'queued') {
                    content.innerHTML = '<div style="color: var(--color-warning);">Content is still being processed. Please try again in a moment.</div>';
                } else if (data.message) {
                    content.innerHTML = `<div style="color: var(--color-text-muted);">${escapeHtml(data.message)}</div>`;
                } else {
                    content.innerHTML = '<div style="color: var(--color-text-muted);">No content available.</div>';
                }
                
                modalContent.appendChild(header);
                modalContent.appendChild(content);
                modal.appendChild(modalContent);
                
                // Close modal on backdrop click
                modal.onclick = (e) => {
                    if (e.target === modal) {
                        document.body.removeChild(modal);
                    }
                };
                
                document.body.appendChild(modal);
            } catch (error) {
                console.error('Error viewing knowledge source:', error);
                alert('Failed to load knowledge source content');
            }
        }
        
        // Batch delete knowledge sources
        async function batchDeleteKnowledge() {
            if (selectedKnowledge.size === 0) return;
            
            const sessionId = sessionFilter.value;
            if (!sessionId) return;
            
            const count = selectedKnowledge.size;
            if (!confirm(`Delete ${count} selected knowledge source${count > 1 ? 's' : ''}? This cannot be undone.`)) {
                return;
            }
            
            const errors = [];
            
            // Delete each selected source
            for (const sourceId of selectedKnowledge) {
                try {
                    const response = await fetch(`/api/sessions/${sessionId}/knowledge/${sourceId}`, {
                        method: 'DELETE'
                    });
                    
                    if (!response.ok) {
                        errors.push(sourceId);
                    }
                    
                    // Small delay between deletions to avoid rate limiting
                    await new Promise(resolve => setTimeout(resolve, 200));
                } catch (error) {
                    console.error('Error deleting source:', sourceId, error);
                    errors.push(sourceId);
                }
            }
            
            // Clear selection
            selectedKnowledge.clear();
            
            // Show errors if any
            if (errors.length > 0) {
                alert(`Failed to delete ${errors.length} source(s)`);
            }
            
            // Reload knowledge sources
            await loadKnowledgeSources(sessionId);
        }
        
        // Select/deselect all
        function toggleSelectAll() {
            const checkboxes = document.querySelectorAll('.knowledge-checkbox');
            const selectAllBtn = document.getElementById('selectAllBtn');
            const allChecked = Array.from(checkboxes).every(cb => cb.checked);
            
            checkboxes.forEach(checkbox => {
                checkbox.checked = !allChecked;
                const sourceId = checkbox.closest('[data-source-id]').dataset.sourceId;
                if (!allChecked) {
                    selectedKnowledge.add(sourceId);
                } else {
                    selectedKnowledge.delete(sourceId);
                }
            });
            
            selectAllBtn.textContent = allChecked ? 'Select All' : 'Select None';
            updateSelectedCount();
        }
        
        // Track upload progress
        let uploadQueue = [];
        let uploadErrors = [];
        
        // Upload file with progress tracking
        async function uploadFile(file, updateProgress = true) {
            const sessionId = sessionFilter.value;
            if (!sessionId) {
                alert('Please select a session first');
                return { success: false, error: 'No session selected' };
            }
            
            const fileId = `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            
            if (updateProgress) {
                updateUploadProgress(fileId, file.name, 'uploading');
            }
            
            const formData = new FormData();
            formData.append('file', file);
            
            try {
                const response = await fetch(`/api/sessions/${sessionId}/knowledge`, {
                    method: 'POST',
                    body: formData
                });
                
                if (!response.ok) {
                    let message = 'Upload failed';
                    try {
                        const error = await response.json();
                        message = error?.error || message;
                    } catch (_) {
                        const text = await response.text();
                        message = text?.slice(0, 200) || message;
                    }
                    throw new Error(message);
                }
                
                const result = await response.json();
                console.log('Upload successful:', result);
                
                if (updateProgress) {
                    updateUploadProgress(fileId, file.name, 'completed');
                }
                
                // Start polling for status updates
                pollKnowledgeStatus(sessionId, result.sourceId);
                
                return { success: true, result };
            } catch (error) {
                console.error('Upload error:', error);
                if (updateProgress) {
                    updateUploadProgress(fileId, file.name, 'failed', error.message);
                }
                return { success: false, error: error.message };
            }
        }
        
        // Upload multiple files with sequential processing to avoid rate limiting
        async function uploadFiles(files) {
            const sessionId = sessionFilter.value;
            if (!sessionId) {
                alert('Please select a session first');
                return;
            }
            
            uploadQueue = [];
            uploadErrors = [];
            
            // Show upload progress UI
            const progressDiv = document.getElementById('uploadProgress');
            const progressList = document.getElementById('uploadProgressList');
            progressDiv.style.display = 'block';
            progressList.innerHTML = '';
            
            // Process files sequentially with a small delay to avoid rate limiting
            for (const file of Array.from(files)) {
                const result = await uploadFile(file, true);
                if (!result.success) {
                    uploadErrors.push({ file: file.name, error: result.error });
                }
                // Add a small delay between uploads to avoid rate limiting
                if (files.length > 1) {
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
            }
            
            // Reload knowledge sources with a delay
            setTimeout(async () => {
                await loadKnowledgeSources(sessionId);
            }, 1000);
            
            // Show any errors
            if (uploadErrors.length > 0) {
                const errorMessages = uploadErrors.map(e => `${e.file}: ${e.error}`).join('\n');
                alert(`Some files failed to upload:\n\n${errorMessages}`);
            }
            
            // Hide progress UI after a delay
            setTimeout(() => {
                progressDiv.style.display = 'none';
            }, 3000);
        }
        
        // Update upload progress UI
        function updateUploadProgress(fileId, fileName, status, error = null) {
            const progressList = document.getElementById('uploadProgressList');
            let item = document.getElementById(`upload-${fileId}`);
            
            if (!item) {
                item = document.createElement('div');
                item.id = `upload-${fileId}`;
                item.style.padding = '8px';
                item.style.borderBottom = '1px solid var(--color-border)';
                progressList.appendChild(item);
            }
            
            let statusBadge = '';
            switch(status) {
                case 'uploading':
                    statusBadge = '<span style="background: var(--color-warning); color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.85rem;">Uploading...</span>';
                    break;
                case 'completed':
                    statusBadge = '<span style="background: var(--color-success); color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.85rem;">Completed</span>';
                    break;
                case 'failed':
                    statusBadge = '<span style="background: var(--color-danger); color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.85rem;">Failed</span>';
                    break;
            }
            
            item.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <span>${escapeHtml(fileName)}</span>
                    ${statusBadge}
                </div>
                ${error ? `<div style="color: var(--color-danger); font-size: 0.85rem; margin-top: 4px;">${escapeHtml(error)}</div>` : ''}
            `;
        }
        
        // Poll for knowledge source status
        async function pollKnowledgeStatus(sessionId, sourceId) {
            const maxAttempts = 30; // Poll for up to 30 seconds
            let attempts = 0;
            
            const pollInterval = setInterval(async () => {
                attempts++;
                
                try {
                    const response = await fetch(`/api/sessions/${sessionId}/knowledge/${sourceId}`);
                    if (!response.ok) throw new Error('Failed to get status');
                    
                    const source = await response.json();
                    
                    if (source.status === 'ready' || source.status === 'error' || attempts >= maxAttempts) {
                        clearInterval(pollInterval);
                        await loadKnowledgeSources(sessionId);
                    }
                } catch (error) {
                    console.error('Error polling status:', error);
                    clearInterval(pollInterval);
                }
            }, 1000);
        }
        
        // Delete knowledge source
        async function deleteKnowledgeSource(sessionId, sourceId) {
            if (!confirm('Delete this knowledge source? This cannot be undone.')) {
                return;
            }
            
            try {
                const response = await fetch(`/api/sessions/${sessionId}/knowledge/${sourceId}`, {
                    method: 'DELETE'
                });
                
                if (!response.ok) throw new Error('Delete failed');
                
                await loadKnowledgeSources(sessionId);
            } catch (error) {
                console.error('Delete error:', error);
                alert('Failed to delete knowledge source');
            }
        }
        
        // File input handlers
        selectFileBtn.onclick = () => fileInput.click();
        
        fileInput.onchange = (e) => {
            const files = e.target.files;
            if (files && files.length > 0) {
                if (files.length === 1) {
                    // Single file - use original behavior
                    uploadFile(files[0], false).then(() => {
                        // Add delay before reloading to avoid rate limiting
                        setTimeout(() => {
                            loadKnowledgeSources(sessionFilter.value);
                        }, 1000);
                    });
                } else {
                    // Multiple files - use batch upload
                    uploadFiles(files);
                }
                fileInput.value = ''; // Reset input
            }
        };
        
        // Drag and drop handlers
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.style.borderColor = 'var(--color-primary)';
            uploadArea.style.background = 'var(--color-primary-bg)';
        });
        
        uploadArea.addEventListener('dragleave', (e) => {
            e.preventDefault();
            uploadArea.style.borderColor = 'var(--color-border)';
            uploadArea.style.background = 'var(--color-bg-secondary)';
        });
        
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.style.borderColor = 'var(--color-border)';
            uploadArea.style.background = 'var(--color-bg-secondary)';
            
            const files = e.dataTransfer.files;
            if (files && files.length > 0) {
                if (files.length === 1) {
                    // Single file - use original behavior
                    uploadFile(files[0], false).then(() => {
                        // Add delay before reloading to avoid rate limiting
                        setTimeout(() => {
                            loadKnowledgeSources(sessionFilter.value);
                        }, 1000);
                    });
                } else {
                    // Multiple files - use batch upload
                    uploadFiles(files);
                }
            }
        });
        
        // Update search to use mixed retrieval
        async function searchEmbeddings() {
            const query = searchQuery.value.trim();
            if (!query) return;
            
            searchResultsSection.style.display = 'block';
            searchResults.innerHTML = '<div style="padding: 20px; text-align: center;">Searching...</div>';
            
            try {
                const response = await fetch('/api/search', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        query,
                        limit: parseInt(searchLimit.value),
                        sessionId: sessionFilter.value || null,
                        include: 'both'  // Search both transcripts and knowledge
                    })
                });
                
                if (!response.ok) throw new Error('Search failed');
                
                const result = await response.json();
                
                if (result.results.length === 0) {
                    searchResults.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--color-text-muted);">No matching results found</div>';
                } else {
                    searchResults.innerHTML = '';
                    
                    const headerDiv = document.createElement('div');
                    headerDiv.style.padding = '12px 16px';
                    headerDiv.style.fontWeight = '600';
                    headerDiv.textContent = `Search Results (${result.totalResults}):`;
                    searchResults.appendChild(headerDiv);
                    
                    // Display mixed results with source attribution
                    result.results.forEach(item => {
                        const row = document.createElement('div');
                        row.className = 'row';
                        row.style.padding = '12px 16px';
                        row.style.borderBottom = '1px solid var(--color-border)';
                        row.style.flexDirection = 'column';
                        row.style.gap = '8px';
                        
                        // Add source badge
                        const sourceBadge = item.source === 'knowledge' 
                            ? `<span style="background: var(--color-info); color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.85rem;">Knowledge: ${escapeHtml(item.attribution.sourceName)}</span>`
                            : '<span style="background: var(--color-primary); color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.85rem;">Transcript</span>';
                        
                        const metaDiv = document.createElement('div');
                        metaDiv.style.fontSize = '0.85rem';
                        metaDiv.style.color = 'var(--color-text-muted)';
                        metaDiv.innerHTML = `
                            ${sourceBadge}
                            <span style="margin-left: 8px; background: var(--color-success); color: white; padding: 2px 6px; border-radius: 4px;">Score: ${(1 - item.distance).toFixed(3)}</span>
                            ${item.attribution && item.attribution.chunkIndex !== undefined ? `<span style="margin-left: 8px;">Chunk #${item.attribution.chunkIndex}</span>` : ''}
                        `;
                        
                        const contentDiv = document.createElement('div');
                        contentDiv.style.lineHeight = '1.5';
                        contentDiv.textContent = item.content;
                        
                        row.appendChild(metaDiv);
                        row.appendChild(contentDiv);
                        searchResults.appendChild(row);
                    });
                }
            } catch (error) {
                console.error('Search error:', error);
                searchResults.innerHTML = '<div style="padding: 20px; color: var(--color-danger);">Search failed</div>';
            }
        }
        
        // Event listeners
        refreshBtn.onclick = loadEmbeddings;
        sessionFilter.onchange = () => {
            loadEmbeddings();
            updateKnowledgeSection();
            selectedKnowledge.clear(); // Clear selection when changing sessions
        };
        searchBtn.onclick = searchEmbeddings;
        
        // Batch action buttons
        const selectAllBtn = document.getElementById('selectAllBtn');
        const batchDeleteBtn = document.getElementById('batchDeleteBtn');
        
        if (selectAllBtn) {
            selectAllBtn.onclick = toggleSelectAll;
        }
        
        if (batchDeleteBtn) {
            batchDeleteBtn.onclick = batchDeleteKnowledge;
        }
        
        searchQuery.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') searchEmbeddings();
        });
        
        // Update navigation session indicator from localStorage
        function updateNavSession() {
            const navSession = document.getElementById('navSession');
            const savedSessionName = localStorage.getItem('currentSessionName');
            if (navSession && savedSessionName) {
                navSession.textContent = savedSessionName;
            }
        }
        
        // Load initial data
        loadSessions();
        loadEmbeddings();
        updateNavSession();
        updateKnowledgeSection();
        
        // Auto-refresh every 30 seconds - store interval ID for cleanup
        const autoRefreshInterval = setInterval(loadEmbeddings, 30000);
        
        // Clean up on page unload
        window.addEventListener('beforeunload', () => {
            clearInterval(autoRefreshInterval);
        });
    </script>
</body>
</html>
